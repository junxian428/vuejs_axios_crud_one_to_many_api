{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/web.immediate.js\");\nconst logger = require('./logging')('kafka-node:ConsumerGroup');\nconst util = require('util');\nconst EventEmitter = require('events');\nconst KafkaClient = require('./kafkaClient');\nconst Offset = require('./offset');\nconst _ = require('lodash');\nconst async = require('async');\nconst validateConfig = require('./utils').validateConfig;\nconst ConsumerGroupRecovery = require('./consumerGroupRecovery');\nconst Heartbeat = require('./consumerGroupHeartbeat');\nconst createTopicPartitionList = require('./utils').createTopicPartitionList;\nconst errors = require('./errors');\nconst NestedError = require('nested-error-stacks');\nconst assert = require('assert');\nconst builtInProtocols = require('./assignment');\nconst LATEST_OFFSET = -1;\nconst EARLIEST_OFFSET = -2;\nconst ACCEPTED_FROM_OFFSET = {\n  latest: LATEST_OFFSET,\n  earliest: EARLIEST_OFFSET,\n  none: false\n};\nconst DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  paused: false,\n  maxNumSegments: 1000,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  maxTickMessages: 1000,\n  fromOffset: 'latest',\n  outOfRangeOffset: 'earliest',\n  sessionTimeout: 30000,\n  retries: 10,\n  retryFactor: 1.8,\n  retryMinTimeout: 1000,\n  commitOffsetsOnFirstJoin: true,\n  connectOnReady: true,\n  migrateHLC: false,\n  onRebalance: null,\n  topicPartitionCheckInterval: 30000,\n  protocol: ['roundrobin'],\n  encoding: 'utf8'\n};\nfunction ConsumerGroup(memberOptions, topics) {\n  EventEmitter.call(this);\n  const self = this;\n  this.options = _.defaults(memberOptions || {}, DEFAULTS);\n  if (!this.options.heartbeatInterval) {\n    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);\n  }\n  if (memberOptions.ssl === true) {\n    memberOptions.ssl = {};\n  }\n  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`);\n  }\n  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`);\n  }\n  memberOptions.clientId = memberOptions.id;\n  this.client = new KafkaClient(memberOptions);\n  if (_.isString(topics)) {\n    topics = [topics];\n  }\n  assert(Array.isArray(topics), 'Array of topics is required');\n  assert(topics.length, 'Array of topics shall not be empty');\n  this.topics = topics;\n  this.recovery = new ConsumerGroupRecovery(this);\n  this.setupProtocols(this.options.protocol);\n  if (this.options.connectOnReady && !this.options.migrateHLC) {\n    this.client.once('ready', this.connect.bind(this));\n  }\n  if (this.options.migrateHLC) {\n    throw new Error('This version of KafkaClient cannot be used to migrate from Zookeeper use older version of kafka-node instead');\n  }\n  this.client.on('error', function (err) {\n    logger.error('Error from %s', self.client.clientId, err);\n    self.emit('error', err);\n  });\n  const recoverFromBrokerChange = _.debounce(function () {\n    logger.debug('brokersChanged refreshing metadata');\n    self.client.refreshBrokerMetadata(function (error) {\n      if (error) {\n        self.emit('error', error);\n        return;\n      }\n      self.reconnectIfNeeded();\n    });\n  }, 200);\n  this.client.on('brokersChanged', function () {\n    self.pause();\n    recoverFromBrokerChange();\n  });\n  this.client.on('reconnect', function () {\n    setImmediate(function () {\n      self.reconnectIfNeeded();\n    });\n  });\n  this.on('offsetOutOfRange', topic => {\n    this.pause();\n    if (this.options.outOfRangeOffset === 'none') {\n      this.emit('error', new errors.InvalidConsumerOffsetError(`Offset out of range for topic \"${topic.topic}\" partition ${topic.partition}`));\n      return;\n    }\n    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];\n    this.getOffset().fetch([topic], (error, result) => {\n      if (error) {\n        this.emit('error', new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error));\n        return;\n      }\n      const offset = _.head(result[topic.topic][topic.partition]);\n      const oldOffset = _.find(this.topicPayloads, {\n        topic: topic.topic,\n        partition: topic.partition\n      }).offset;\n      logger.debug('replacing %s-%s stale offset of %d with %d', topic.topic, topic.partition, oldOffset, offset);\n      this.setOffset(topic.topic, topic.partition, offset);\n      this.resume();\n    });\n  });\n  this._pendingFetches = 0;\n  // 'processingfetch' emits before we start processing new messages\n  // 'done' will be emit when all messages are done emitting\n  this.on('processingfetch', () => this._onFetchProcessing());\n  this.on('done', topics => this._onFetchDone(topics));\n  if (this.options.groupId) {\n    validateConfig('options.groupId', this.options.groupId);\n  }\n  this.isLeader = false;\n  this.coordinatorId = null;\n  this.generationId = null;\n  this.ready = false;\n  this.topicPayloads = [];\n  this.payloadMap = {};\n}\nutil.inherits(ConsumerGroup, EventEmitter);\nConsumerGroup.prototype.reconnectIfNeeded = function () {\n  logger.debug('trying to reconnect if needed');\n  this.paused = false;\n  if (!this.ready && !this.connecting) {\n    if (this.reconnectTimer) {\n      // brokers changed so bypass backoff retry and reconnect now\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.connect();\n  } else if (!this.connecting) {\n    this.fetch();\n  }\n};\nConsumerGroup.prototype.setupProtocols = function (protocols) {\n  if (!Array.isArray(protocols)) {\n    protocols = [protocols];\n  }\n  this.protocols = protocols.map(function (protocol) {\n    if (typeof protocol === 'string') {\n      if (!(protocol in builtInProtocols)) {\n        throw new Error('Unknown built in assignment protocol ' + protocol);\n      }\n      protocol = _.assign({}, builtInProtocols[protocol]);\n    } else {\n      checkProtocol(protocol);\n    }\n    protocol.subscription = this.topics;\n    return protocol;\n  }, this);\n};\nfunction checkProtocol(protocol) {\n  assert(protocol, 'protocol is null');\n  assert(protocol.assign, 'assign function is not defined in the protocol');\n  assert(protocol.name, 'name must be given to protocol');\n  assert(protocol.version >= 0, 'version must be >= 0');\n}\nConsumerGroup.prototype.setCoordinatorId = function (coordinatorId) {\n  this.client.coordinatorId = String(coordinatorId);\n};\nConsumerGroup.prototype.assignPartitions = function (protocol, groupMembers, callback) {\n  logger.debug('Assigning Partitions to members', groupMembers);\n  logger.debug('Using group protocol', protocol);\n  protocol = _.find(this.protocols, {\n    name: protocol\n  });\n  if (!protocol) {\n    callback(new Error('Unknown group protocol: ' + protocol));\n    return;\n  }\n  var self = this;\n  var topics = _(groupMembers).map('subscription').flatten().uniq().value();\n  async.waterfall([function (callback) {\n    logger.debug('loadingMetadata for topics:', topics);\n    self.client.loadMetadataForTopics(topics, callback);\n  }, function (metadataResponse, callback) {\n    var metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n    self.topicPartitionLength = createTopicPartitionLength(metadata, _.difference(topics, Object.keys(metadata)));\n    logger.debug('mapTopicToPartitions', metadata);\n    protocol.assign(metadata, groupMembers, callback);\n  }], callback);\n};\nfunction createTopicPartitionLength(metadata, emptyTopics) {\n  const topicPartitionLength = {};\n  _.forOwn(metadata, function (value, key) {\n    topicPartitionLength[key] = value.length;\n  });\n  for (const topic of emptyTopics) {\n    if (topic in topicPartitionLength) {\n      throw new Error(`Topic ${topic} is not empty`);\n    }\n    topicPartitionLength[topic] = 0;\n  }\n  return topicPartitionLength;\n}\nConsumerGroup.prototype.scheduleTopicPartitionCheck = function () {\n  if (this.isLeader && !this.topicPartitionCheckTimer && !this.closed) {\n    logger.debug(`${this.client.clientId} is leader scheduled new topic/partition check`);\n    this.topicPartitionCheckTimer = setTimeout(() => {\n      this.topicPartitionCheckTimer = null;\n      if (this.closed) return;\n      logger.debug('checking for new topics and partitions');\n      this._checkTopicPartitionChange((error, changed) => {\n        if (error) {\n          this.scheduleTopicPartitionCheck();\n          return this.emit('error', new NestedError('topic/partition change check failed', error));\n        }\n        if (changed) {\n          logger.debug('Topic/Partitions has changed');\n          async.series([callback => this.options.autoCommit && this.generationId != null && this.memberId ? this.commit(true, callback) : callback(null), callback => this.leaveGroup(callback), callback => {\n            this.connect();\n            callback(null);\n          }]);\n        } else {\n          logger.debug('no new Topic/Partitions');\n          this.scheduleTopicPartitionCheck();\n        }\n      });\n    }, this.options.topicPartitionCheckInterval);\n  }\n};\nConsumerGroup.prototype._checkTopicPartitionChange = function (callback) {\n  this.client.loadMetadataForTopics(this.topics, (error, metadataResponse) => {\n    if (error) {\n      return callback(error);\n    }\n    const metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n    const topicOrPartitionsChanged = _.some(this.topicPartitionLength, function (numberOfPartitions, topic) {\n      return numberOfPartitions !== _.get(metadata, `['${topic}'].length`, 0);\n    });\n    callback(null, topicOrPartitionsChanged);\n  });\n};\nfunction mapTopicToPartitions(metadata) {\n  return _.mapValues(metadata, Object.keys);\n}\nConsumerGroup.prototype.handleJoinGroup = function (joinGroupResponse, callback) {\n  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);\n  if (!joinGroupResponse.memberId || !joinGroupResponse.generationId) {\n    callback(new Error('Invalid joinGroupResponse: ' + JSON.stringify(joinGroupResponse)));\n    return;\n  }\n  this.isLeader = joinGroupResponse.leaderId === joinGroupResponse.memberId;\n  this.generationId = joinGroupResponse.generationId;\n  this.memberId = joinGroupResponse.memberId;\n  var groupAssignment;\n  if (this.isLeader) {\n    // assign partitions\n    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);\n  }\n  callback(null, groupAssignment);\n};\nConsumerGroup.prototype.saveDefaultOffsets = function (topicPartitionList, callback) {\n  var self = this;\n  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp => {\n    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];\n    return tp;\n  });\n  self.getOffset().fetch(offsetPayload, function (error, result) {\n    if (error) {\n      return callback(error);\n    }\n    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {\n      return _.mapValues(partitionOffsets, _.head);\n    });\n    callback(null);\n  });\n};\nConsumerGroup.prototype.handleSyncGroup = function (syncGroupResponse, callback) {\n  logger.debug('SyncGroup Response');\n  var self = this;\n  var ownedTopics = Object.keys(syncGroupResponse.partitions);\n  if (ownedTopics.length) {\n    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);\n    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);\n    const useDefaultOffsets = (self.options.fromOffset in ACCEPTED_FROM_OFFSET);\n    let noOffset;\n    async.waterfall([function (callback) {\n      self.fetchOffset(syncGroupResponse.partitions, callback);\n    }, function (offsets, callback) {\n      logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);\n      noOffset = topicPartitionList.some(function (tp) {\n        return offsets[tp.topic][tp.partition] === -1;\n      });\n      if (noOffset) {\n        logger.debug('No saved offsets');\n        if (self.options.fromOffset === 'none') {\n          return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group '${self.options.groupId}'`));\n        }\n        async.parallel([function (callback) {\n          if (useDefaultOffsets) {\n            return self.saveDefaultOffsets(topicPartitionList, callback);\n          }\n          callback(null);\n        }], function (error) {\n          if (error) {\n            return callback(error);\n          }\n          logger.debug('%s defaultOffset Response for %s: %j', self.client.clientId, self.options.fromOffset, self.defaultOffsets);\n          callback(null, offsets);\n        });\n      } else {\n        logger.debug('Has saved offsets');\n        callback(null, offsets);\n      }\n    }, function (offsets, callback) {\n      self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {\n        var offset = offsets[p.topic][p.partition];\n        if (offset === -1) {\n          // -1 means no offset was saved for this topic/partition combo\n          offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;\n        }\n        p.offset = offset;\n        return p;\n      });\n      self.payloadMap = self.buildPayloadMap(self.topicPayloads);\n      if (noOffset && self.options.commitOffsetsOnFirstJoin) {\n        self.commit(true, err => {\n          callback(err, !err ? true : null);\n        });\n      } else {\n        callback(null, true);\n      }\n    }], callback);\n  } else {\n    self.topicPayloads = [];\n    self.payloadMap = {};\n    // no partitions assigned\n    callback(null, false);\n  }\n};\nConsumerGroup.prototype.getDefaultOffset = function (tp, defaultOffset) {\n  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);\n};\nConsumerGroup.prototype.getOffset = function () {\n  if (this.offset) {\n    return this.offset;\n  }\n  this.offset = new Offset(this.client);\n  // we can ignore this since we are already forwarding error event emitted from client\n  this.offset.on('error', _.noop);\n  return this.offset;\n};\nfunction emptyStrIfNull(value) {\n  return value == null ? '' : value;\n}\nConsumerGroup.prototype.connect = function () {\n  if (this.connecting) {\n    logger.warn('Connect ignored. Currently connecting.');\n    return;\n  }\n  if (this.closed) {\n    logger.warn('Connect ignored. Consumer closed.');\n    return;\n  }\n  logger.debug('Connecting %s', this.client.clientId);\n  var self = this;\n  this.connecting = true;\n  this.emit('rebalancing');\n  async.waterfall([function (callback) {\n    if (typeof self.options.onRebalance === 'function') {\n      self.options.onRebalance(self.generationId != null && self.memberId != null, function (error) {\n        if (error) {\n          return callback(error);\n        }\n        callback(null);\n      });\n      return;\n    }\n    callback(null);\n  }, function (callback) {\n    if (self.options.autoCommit && self.generationId != null && self.memberId) {\n      self.commit(true, function (error) {\n        if (error) {\n          return callback(error);\n        }\n        callback(null);\n      });\n      return;\n    }\n    callback(null);\n  }, function (callback) {\n    if (self.client.coordinatorId) {\n      return callback(null, null);\n    }\n    self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);\n  }, function (coordinatorInfo, callback) {\n    logger.debug('GroupCoordinator Response:', coordinatorInfo);\n    if (coordinatorInfo) {\n      self.setCoordinatorId(coordinatorInfo.coordinatorId);\n    }\n    self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols, callback);\n  }, function (joinGroupResponse, callback) {\n    self.handleJoinGroup(joinGroupResponse, callback);\n  }, function (groupAssignment, callback) {\n    logger.debug('SyncGroup Request from %s', self.memberId);\n    self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);\n  }, function (syncGroupResponse, callback) {\n    self.handleSyncGroup(syncGroupResponse, callback);\n  }], function (error, startFetch) {\n    self.connecting = false;\n    self.rebalancing = false;\n    if (error) {\n      return self.recovery.tryToRecoverFrom(error, 'connect');\n    }\n    self.ready = true;\n    self.recovery.clearError();\n    logger.debug('generationId', self.generationId);\n    logger.debug('startFetch is', startFetch);\n    self._resetFetchState();\n    if (startFetch) {\n      self.clearPendingFetches();\n      self.fetch();\n    }\n    self.scheduleTopicPartitionCheck();\n    self.startHeartbeats();\n    self.emit('connect');\n    self.emit('rebalanced');\n  });\n};\nConsumerGroup.prototype.clearPendingFetches = function () {\n  _.forEach(this.client.getBrokers(true), broker => {\n    if (broker.socket.waiting) {\n      broker.socket.waiting = false;\n      this.client.clearCallbackQueue(broker.socket);\n    }\n  });\n};\nConsumerGroup.prototype.scheduleReconnect = function (timeout) {\n  assert(timeout);\n  this.rebalancing = true;\n  if (this.reconnectTimer) {\n    clearTimeout(this.reconnectTimer);\n  }\n  var self = this;\n  this.reconnectTimer = setTimeout(function () {\n    self.reconnectTimer = null;\n    self.connect();\n  }, timeout);\n};\nConsumerGroup.prototype.startHeartbeats = function () {\n  assert(this.options.sessionTimeout > 0);\n  assert(this.ready, 'consumerGroup is not ready');\n  const heartbeatIntervalMs = this.options.heartbeatInterval || Math.floor(this.options.sessionTimeout / 3);\n  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);\n  this.stopHeartbeats();\n  let heartbeat = this.sendHeartbeat();\n  this.heartbeatInterval = setInterval(() => {\n    // only send another heartbeat if we got a response from the last one\n    if (heartbeat.verifyResolved()) {\n      heartbeat = this.sendHeartbeat();\n    }\n  }, heartbeatIntervalMs);\n};\nConsumerGroup.prototype.stopHeartbeats = function () {\n  this.heartbeatInterval && clearInterval(this.heartbeatInterval);\n};\nConsumerGroup.prototype.leaveGroup = function (callback) {\n  logger.debug('%s leaving group', this.client.clientId);\n  var self = this;\n  this.stopHeartbeats();\n  if (self.generationId != null && self.memberId) {\n    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {\n      self.generationId = null;\n      callback(error);\n    });\n  } else {\n    callback(null);\n  }\n};\nConsumerGroup.prototype.sendHeartbeat = function () {\n  assert(this.memberId, 'invalid memberId');\n  assert(this.generationId >= 0, 'invalid generationId');\n  // logger.debug('%s â¤ï¸  ->', this.client.clientId);\n  var self = this;\n  function heartbeatCallback(error) {\n    if (error) {\n      logger.warn('%s Heartbeat error:', self.client.clientId, error);\n      self.recovery.tryToRecoverFrom(error, 'heartbeat');\n    }\n    // logger.debug('%s ðŸ’š <-', self.client.clientId, error);\n  }\n\n  const heartbeat = new Heartbeat(this.client, heartbeatCallback);\n  heartbeat.send(this.options.groupId, this.generationId, this.memberId);\n  return heartbeat;\n};\nConsumerGroup.prototype.fetchOffset = function (payloads, cb) {\n  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);\n};\nConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {\n  if (this.generationId && this.memberId) {\n    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n};\nConsumerGroup.prototype.addTopics = function (topics, cb) {\n  topics = Array.isArray(topics) ? topics : [topics];\n  if (!this.client.ready) {\n    this.client.once('ready', () => this.addTopics(topics, cb));\n    return;\n  }\n  async.series([callback => this.client.topicExists(topics, callback), callback => this.options.autoCommit && this.generationId != null && this.memberId ? this.commit(true, callback) : callback(null), callback => this.leaveGroup(callback), callback => {\n    this.topics = this.topics.concat(topics);\n    this.setupProtocols(this.options.protocol);\n    this.connect();\n    callback(null);\n  }], error => error ? cb(error) : cb(null, `Add Topics ${topics.join(',')} Successfully`));\n};\nConsumerGroup.prototype.removeTopics = function (topics, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n  async.series([callback => this.client.topicExists(topics, callback), callback => this.options.autoCommit && this.generationId != null && this.memberId ? this.commit(true, callback) : callback(null), callback => this.leaveGroup(callback), callback => {\n    this.topics = _.difference(this.topics, topics);\n    this.setupProtocols(this.options.protocol);\n    this.connect();\n    callback(null);\n  }], error => error ? cb(error) : cb(null, `Remove Topics ${topics.join(',')} Successfully`));\n};\nConsumerGroup.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = {\n      topic: p\n    };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n    return p;\n  });\n};\nConsumerGroup.prototype.buildPayloadMap = function (payloads) {\n  const payloadMap = {};\n  payloads.forEach(({\n    topic,\n    partition,\n    offset\n  }) => {\n    payloadMap[topic] = payloadMap[topic] || {};\n    payloadMap[topic][partition] = offset;\n  });\n  return payloadMap;\n};\n\n/*\n * Update offset info in current payloads\n * @param {Object} Topic-partition-offset\n * @param {Boolean} Don't commit when initing consumer\n */\nConsumerGroup.prototype.updateOffsets = function (topics, initing) {\n  this.topicPayloads.forEach(p => {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;else p.offset = offset;\n      // Update the map\n      this.needToCommit = true;\n    }\n    this.payloadMap[p.topic] = this.payloadMap[p.topic] || {};\n    this.payloadMap[p.topic][p.partition] = p.offset;\n  });\n  if (this.options.autoCommit && !initing) {\n    this.autoCommit(false, function (err) {\n      err && logger.debug('auto commit offset', err);\n    });\n  }\n};\nConsumerGroup.prototype._onFetchDone = function (topics) {\n  this.updateOffsets(topics);\n  if (--this._pendingFetches > 0) {\n    return;\n  }\n  this._isFetchPending = false;\n  if (!this.paused) {\n    setImmediate(() => this.fetch());\n  }\n};\nConsumerGroup.prototype._resetFetchState = function () {\n  this._pendingFetches = 0;\n  this._isFetchPending = false;\n};\nConsumerGroup.prototype._onFetchProcessing = function () {\n  this._pendingFetches++;\n};\nConsumerGroup.prototype.fetch = function () {\n  if (!this.ready || this.rebalancing || this.paused || this.closing) {\n    return;\n  }\n  if (this._isFetchPending) {\n    return;\n  }\n  this._isFetchPending = true;\n  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages, error => {\n    if (error) {\n      this._resetFetchState();\n    }\n  });\n};\nConsumerGroup.prototype.setOffset = function (topic, partition, offset) {\n  this.topicPayloads.every(function (p) {\n    // eslint-disable-next-line eqeqeq\n    if (p.topic === topic && p.partition == partition) {\n      p.offset = offset;\n      return false;\n    }\n    return true;\n  });\n};\nConsumerGroup.prototype.pause = function () {\n  this.paused = true;\n};\nConsumerGroup.prototype.resume = function () {\n  this.paused = false;\n  this.fetch();\n};\nfunction autoCommit(force, cb) {\n  if (arguments.length === 1) {\n    cb = force;\n    force = false;\n  }\n  if (!force) {\n    if (this.committing) return cb(null, 'Offset committing');\n    if (!this.needToCommit) return cb(null, 'Commit not needed');\n  }\n  this.needToCommit = false;\n  this.committing = true;\n  setTimeout(function () {\n    this.committing = false;\n  }.bind(this), this.options.autoCommitIntervalMs).unref();\n  var commits = this.topicPayloads.filter(function (p) {\n    return p.offset !== -1;\n  });\n  if (commits.length) {\n    this.sendOffsetCommitRequest(commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n}\nConsumerGroup.prototype.commit = ConsumerGroup.prototype.autoCommit = autoCommit;\nConsumerGroup.prototype.close = function (force, cb) {\n  var self = this;\n  this.ready = false;\n  this.stopHeartbeats();\n  clearTimeout(this.topicPartitionCheckTimer);\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n  async.series([function (callback) {\n    if (force) {\n      self.commit(true, callback);\n      return;\n    }\n    callback(null);\n  }, function (callback) {\n    self.leaveGroup(function (error) {\n      if (error) {\n        logger.error('Leave group failed with', error);\n      }\n      callback(null);\n    });\n  }, function (callback) {\n    self.client.close(callback);\n  }], function (error) {\n    if (error) {\n      return cb(error);\n    }\n    self.closed = true;\n    cb(null);\n  });\n};\nmodule.exports = ConsumerGroup;","map":{"version":3,"names":["require","logger","util","EventEmitter","KafkaClient","Offset","_","async","validateConfig","ConsumerGroupRecovery","Heartbeat","createTopicPartitionList","errors","NestedError","assert","builtInProtocols","LATEST_OFFSET","EARLIEST_OFFSET","ACCEPTED_FROM_OFFSET","latest","earliest","none","DEFAULTS","groupId","autoCommit","autoCommitIntervalMs","fetchMaxWaitMs","paused","maxNumSegments","fetchMinBytes","fetchMaxBytes","maxTickMessages","fromOffset","outOfRangeOffset","sessionTimeout","retries","retryFactor","retryMinTimeout","commitOffsetsOnFirstJoin","connectOnReady","migrateHLC","onRebalance","topicPartitionCheckInterval","protocol","encoding","ConsumerGroup","memberOptions","topics","call","self","options","defaults","heartbeatInterval","Math","floor","ssl","Error","Object","keys","join","clientId","id","client","isString","Array","isArray","length","recovery","setupProtocols","once","connect","bind","on","err","error","emit","recoverFromBrokerChange","debounce","debug","refreshBrokerMetadata","reconnectIfNeeded","pause","setImmediate","topic","InvalidConsumerOffsetError","partition","time","getOffset","fetch","result","offset","head","oldOffset","find","topicPayloads","setOffset","resume","_pendingFetches","_onFetchProcessing","_onFetchDone","isLeader","coordinatorId","generationId","ready","payloadMap","inherits","prototype","connecting","reconnectTimer","clearTimeout","protocols","map","assign","checkProtocol","subscription","name","version","setCoordinatorId","String","assignPartitions","groupMembers","callback","flatten","uniq","value","waterfall","loadMetadataForTopics","metadataResponse","metadata","mapTopicToPartitions","topicPartitionLength","createTopicPartitionLength","difference","emptyTopics","forOwn","key","scheduleTopicPartitionCheck","topicPartitionCheckTimer","closed","setTimeout","_checkTopicPartitionChange","changed","series","memberId","commit","leaveGroup","topicOrPartitionsChanged","some","numberOfPartitions","get","mapValues","handleJoinGroup","joinGroupResponse","JSON","stringify","leaderId","groupAssignment","groupProtocol","members","saveDefaultOffsets","topicPartitionList","offsetPayload","cloneDeep","tp","defaultOffsets","partitionOffsets","handleSyncGroup","syncGroupResponse","ownedTopics","partitions","useDefaultOffsets","noOffset","fetchOffset","offsets","parallel","buildPayloads","p","getDefaultOffset","buildPayloadMap","defaultOffset","noop","emptyStrIfNull","warn","sendGroupCoordinatorRequest","coordinatorInfo","sendJoinGroupRequest","sendSyncGroupRequest","startFetch","rebalancing","tryToRecoverFrom","clearError","_resetFetchState","clearPendingFetches","startHeartbeats","forEach","getBrokers","broker","socket","waiting","clearCallbackQueue","scheduleReconnect","timeout","heartbeatIntervalMs","stopHeartbeats","heartbeat","sendHeartbeat","setInterval","verifyResolved","clearInterval","sendLeaveGroupRequest","heartbeatCallback","send","payloads","cb","sendOffsetFetchV1Request","sendOffsetCommitRequest","commits","sendOffsetCommitV2Request","addTopics","topicExists","concat","removeTopics","maxBytes","updateOffsets","initing","isEmpty","undefined","needToCommit","_isFetchPending","closing","sendFetchRequest","every","force","arguments","committing","unref","filter","close","module","exports"],"sources":["D:/Project/VUEJSSPRING_CRUD_JWT/vue-crud-api-jwt-vuex/node_modules/kafka-node/lib/consumerGroup.js"],"sourcesContent":["'use strict';\n\nconst logger = require('./logging')('kafka-node:ConsumerGroup');\nconst util = require('util');\nconst EventEmitter = require('events');\nconst KafkaClient = require('./kafkaClient');\nconst Offset = require('./offset');\nconst _ = require('lodash');\nconst async = require('async');\nconst validateConfig = require('./utils').validateConfig;\nconst ConsumerGroupRecovery = require('./consumerGroupRecovery');\nconst Heartbeat = require('./consumerGroupHeartbeat');\nconst createTopicPartitionList = require('./utils').createTopicPartitionList;\nconst errors = require('./errors');\nconst NestedError = require('nested-error-stacks');\n\nconst assert = require('assert');\nconst builtInProtocols = require('./assignment');\n\nconst LATEST_OFFSET = -1;\nconst EARLIEST_OFFSET = -2;\nconst ACCEPTED_FROM_OFFSET = {\n  latest: LATEST_OFFSET,\n  earliest: EARLIEST_OFFSET,\n  none: false\n};\n\nconst DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  paused: false,\n  maxNumSegments: 1000,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  maxTickMessages: 1000,\n  fromOffset: 'latest',\n  outOfRangeOffset: 'earliest',\n  sessionTimeout: 30000,\n  retries: 10,\n  retryFactor: 1.8,\n  retryMinTimeout: 1000,\n  commitOffsetsOnFirstJoin: true,\n  connectOnReady: true,\n  migrateHLC: false,\n  onRebalance: null,\n  topicPartitionCheckInterval: 30000,\n  protocol: ['roundrobin'],\n  encoding: 'utf8'\n};\n\nfunction ConsumerGroup (memberOptions, topics) {\n  EventEmitter.call(this);\n  const self = this;\n  this.options = _.defaults(memberOptions || {}, DEFAULTS);\n\n  if (!this.options.heartbeatInterval) {\n    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);\n  }\n\n  if (memberOptions.ssl === true) {\n    memberOptions.ssl = {};\n  }\n\n  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(\n      `fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`\n    );\n  }\n\n  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(\n      `outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(\n        ', '\n      )}`\n    );\n  }\n\n  memberOptions.clientId = memberOptions.id;\n  this.client = new KafkaClient(memberOptions);\n\n  if (_.isString(topics)) {\n    topics = [topics];\n  }\n\n  assert(Array.isArray(topics), 'Array of topics is required');\n  assert(topics.length, 'Array of topics shall not be empty');\n\n  this.topics = topics;\n\n  this.recovery = new ConsumerGroupRecovery(this);\n\n  this.setupProtocols(this.options.protocol);\n\n  if (this.options.connectOnReady && !this.options.migrateHLC) {\n    this.client.once('ready', this.connect.bind(this));\n  }\n\n  if (this.options.migrateHLC) {\n    throw new Error(\n      'This version of KafkaClient cannot be used to migrate from Zookeeper use older version of kafka-node instead'\n    );\n  }\n\n  this.client.on('error', function (err) {\n    logger.error('Error from %s', self.client.clientId, err);\n    self.emit('error', err);\n  });\n\n  const recoverFromBrokerChange = _.debounce(function () {\n    logger.debug('brokersChanged refreshing metadata');\n    self.client.refreshBrokerMetadata(function (error) {\n      if (error) {\n        self.emit('error', error);\n        return;\n      }\n      self.reconnectIfNeeded();\n    });\n  }, 200);\n\n  this.client.on('brokersChanged', function () {\n    self.pause();\n    recoverFromBrokerChange();\n  });\n\n  this.client.on('reconnect', function () {\n    setImmediate(function () {\n      self.reconnectIfNeeded();\n    });\n  });\n\n  this.on('offsetOutOfRange', topic => {\n    this.pause();\n    if (this.options.outOfRangeOffset === 'none') {\n      this.emit(\n        'error',\n        new errors.InvalidConsumerOffsetError(\n          `Offset out of range for topic \"${topic.topic}\" partition ${topic.partition}`\n        )\n      );\n      return;\n    }\n\n    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];\n\n    this.getOffset().fetch([topic], (error, result) => {\n      if (error) {\n        this.emit(\n          'error',\n          new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error)\n        );\n        return;\n      }\n      const offset = _.head(result[topic.topic][topic.partition]);\n      const oldOffset = _.find(this.topicPayloads, { topic: topic.topic, partition: topic.partition }).offset;\n\n      logger.debug('replacing %s-%s stale offset of %d with %d', topic.topic, topic.partition, oldOffset, offset);\n\n      this.setOffset(topic.topic, topic.partition, offset);\n      this.resume();\n    });\n  });\n\n  this._pendingFetches = 0;\n  // 'processingfetch' emits before we start processing new messages\n  // 'done' will be emit when all messages are done emitting\n  this.on('processingfetch', () => this._onFetchProcessing());\n  this.on('done', topics => this._onFetchDone(topics));\n\n  if (this.options.groupId) {\n    validateConfig('options.groupId', this.options.groupId);\n  }\n\n  this.isLeader = false;\n  this.coordinatorId = null;\n  this.generationId = null;\n  this.ready = false;\n  this.topicPayloads = [];\n  this.payloadMap = {};\n}\n\nutil.inherits(ConsumerGroup, EventEmitter);\n\nConsumerGroup.prototype.reconnectIfNeeded = function () {\n  logger.debug('trying to reconnect if needed');\n  this.paused = false;\n  if (!this.ready && !this.connecting) {\n    if (this.reconnectTimer) {\n      // brokers changed so bypass backoff retry and reconnect now\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.connect();\n  } else if (!this.connecting) {\n    this.fetch();\n  }\n};\n\nConsumerGroup.prototype.setupProtocols = function (protocols) {\n  if (!Array.isArray(protocols)) {\n    protocols = [protocols];\n  }\n\n  this.protocols = protocols.map(function (protocol) {\n    if (typeof protocol === 'string') {\n      if (!(protocol in builtInProtocols)) {\n        throw new Error('Unknown built in assignment protocol ' + protocol);\n      }\n      protocol = _.assign({}, builtInProtocols[protocol]);\n    } else {\n      checkProtocol(protocol);\n    }\n\n    protocol.subscription = this.topics;\n    return protocol;\n  }, this);\n};\n\nfunction checkProtocol (protocol) {\n  assert(protocol, 'protocol is null');\n  assert(protocol.assign, 'assign function is not defined in the protocol');\n  assert(protocol.name, 'name must be given to protocol');\n  assert(protocol.version >= 0, 'version must be >= 0');\n}\n\nConsumerGroup.prototype.setCoordinatorId = function (coordinatorId) {\n  this.client.coordinatorId = String(coordinatorId);\n};\n\nConsumerGroup.prototype.assignPartitions = function (protocol, groupMembers, callback) {\n  logger.debug('Assigning Partitions to members', groupMembers);\n  logger.debug('Using group protocol', protocol);\n\n  protocol = _.find(this.protocols, { name: protocol });\n  if (!protocol) {\n    callback(new Error('Unknown group protocol: ' + protocol));\n    return;\n  }\n\n  var self = this;\n  var topics = _(groupMembers)\n    .map('subscription')\n    .flatten()\n    .uniq()\n    .value();\n\n  async.waterfall(\n    [\n      function (callback) {\n        logger.debug('loadingMetadata for topics:', topics);\n        self.client.loadMetadataForTopics(topics, callback);\n      },\n\n      function (metadataResponse, callback) {\n        var metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n\n        self.topicPartitionLength = createTopicPartitionLength(metadata, _.difference(topics, Object.keys(metadata)));\n\n        logger.debug('mapTopicToPartitions', metadata);\n        protocol.assign(metadata, groupMembers, callback);\n      }\n    ],\n    callback\n  );\n};\n\nfunction createTopicPartitionLength (metadata, emptyTopics) {\n  const topicPartitionLength = {};\n  _.forOwn(metadata, function (value, key) {\n    topicPartitionLength[key] = value.length;\n  });\n\n  for (const topic of emptyTopics) {\n    if (topic in topicPartitionLength) {\n      throw new Error(`Topic ${topic} is not empty`);\n    }\n    topicPartitionLength[topic] = 0;\n  }\n  return topicPartitionLength;\n}\n\nConsumerGroup.prototype.scheduleTopicPartitionCheck = function () {\n  if (this.isLeader && !this.topicPartitionCheckTimer && !this.closed) {\n    logger.debug(`${this.client.clientId} is leader scheduled new topic/partition check`);\n    this.topicPartitionCheckTimer = setTimeout(() => {\n      this.topicPartitionCheckTimer = null;\n      if (this.closed) return;\n      logger.debug('checking for new topics and partitions');\n      this._checkTopicPartitionChange((error, changed) => {\n        if (error) {\n          this.scheduleTopicPartitionCheck();\n          return this.emit('error', new NestedError('topic/partition change check failed', error));\n        }\n\n        if (changed) {\n          logger.debug('Topic/Partitions has changed');\n          async.series([\n            callback =>\n              this.options.autoCommit && this.generationId != null && this.memberId\n                ? this.commit(true, callback)\n                : callback(null),\n            callback => this.leaveGroup(callback),\n            callback => {\n              this.connect();\n              callback(null);\n            }\n          ]);\n        } else {\n          logger.debug('no new Topic/Partitions');\n          this.scheduleTopicPartitionCheck();\n        }\n      });\n    }, this.options.topicPartitionCheckInterval);\n  }\n};\n\nConsumerGroup.prototype._checkTopicPartitionChange = function (callback) {\n  this.client.loadMetadataForTopics(this.topics, (error, metadataResponse) => {\n    if (error) {\n      return callback(error);\n    }\n    const metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n\n    const topicOrPartitionsChanged = _.some(this.topicPartitionLength, function (numberOfPartitions, topic) {\n      return numberOfPartitions !== _.get(metadata, `['${topic}'].length`, 0);\n    });\n    callback(null, topicOrPartitionsChanged);\n  });\n};\n\nfunction mapTopicToPartitions (metadata) {\n  return _.mapValues(metadata, Object.keys);\n}\n\nConsumerGroup.prototype.handleJoinGroup = function (joinGroupResponse, callback) {\n  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);\n  if (!joinGroupResponse.memberId || !joinGroupResponse.generationId) {\n    callback(new Error('Invalid joinGroupResponse: ' + JSON.stringify(joinGroupResponse)));\n    return;\n  }\n\n  this.isLeader = joinGroupResponse.leaderId === joinGroupResponse.memberId;\n  this.generationId = joinGroupResponse.generationId;\n  this.memberId = joinGroupResponse.memberId;\n\n  var groupAssignment;\n  if (this.isLeader) {\n    // assign partitions\n    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);\n  }\n  callback(null, groupAssignment);\n};\n\nConsumerGroup.prototype.saveDefaultOffsets = function (topicPartitionList, callback) {\n  var self = this;\n  const offsetPayload = _(topicPartitionList)\n    .cloneDeep()\n    .map(tp => {\n      tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];\n      return tp;\n    });\n\n  self.getOffset().fetch(offsetPayload, function (error, result) {\n    if (error) {\n      return callback(error);\n    }\n    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {\n      return _.mapValues(partitionOffsets, _.head);\n    });\n    callback(null);\n  });\n};\n\nConsumerGroup.prototype.handleSyncGroup = function (syncGroupResponse, callback) {\n  logger.debug('SyncGroup Response');\n  var self = this;\n  var ownedTopics = Object.keys(syncGroupResponse.partitions);\n  if (ownedTopics.length) {\n    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);\n\n    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);\n    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;\n\n    let noOffset;\n    async.waterfall(\n      [\n        function (callback) {\n          self.fetchOffset(syncGroupResponse.partitions, callback);\n        },\n        function (offsets, callback) {\n          logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);\n\n          noOffset = topicPartitionList.some(function (tp) {\n            return offsets[tp.topic][tp.partition] === -1;\n          });\n\n          if (noOffset) {\n            logger.debug('No saved offsets');\n\n            if (self.options.fromOffset === 'none') {\n              return callback(\n                new Error(\n                  `${self.client.clientId} owns topics and partitions which contains no saved offsets for group '${\n                    self.options.groupId\n                  }'`\n                )\n              );\n            }\n\n            async.parallel(\n              [\n                function (callback) {\n                  if (useDefaultOffsets) {\n                    return self.saveDefaultOffsets(topicPartitionList, callback);\n                  }\n                  callback(null);\n                }\n              ],\n              function (error) {\n                if (error) {\n                  return callback(error);\n                }\n                logger.debug(\n                  '%s defaultOffset Response for %s: %j',\n                  self.client.clientId,\n                  self.options.fromOffset,\n                  self.defaultOffsets\n                );\n                callback(null, offsets);\n              }\n            );\n          } else {\n            logger.debug('Has saved offsets');\n            callback(null, offsets);\n          }\n        },\n        function (offsets, callback) {\n          self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {\n            var offset = offsets[p.topic][p.partition];\n            if (offset === -1) {\n              // -1 means no offset was saved for this topic/partition combo\n              offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;\n            }\n            p.offset = offset;\n            return p;\n          });\n          self.payloadMap = self.buildPayloadMap(self.topicPayloads);\n          if (noOffset && self.options.commitOffsetsOnFirstJoin) {\n            self.commit(true, err => {\n              callback(err, !err ? true : null);\n            });\n          } else {\n            callback(null, true);\n          }\n        }\n      ],\n      callback\n    );\n  } else {\n    self.topicPayloads = [];\n    self.payloadMap = {};\n    // no partitions assigned\n    callback(null, false);\n  }\n};\n\nConsumerGroup.prototype.getDefaultOffset = function (tp, defaultOffset) {\n  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);\n};\n\nConsumerGroup.prototype.getOffset = function () {\n  if (this.offset) {\n    return this.offset;\n  }\n  this.offset = new Offset(this.client);\n  // we can ignore this since we are already forwarding error event emitted from client\n  this.offset.on('error', _.noop);\n  return this.offset;\n};\n\nfunction emptyStrIfNull (value) {\n  return value == null ? '' : value;\n}\n\nConsumerGroup.prototype.connect = function () {\n  if (this.connecting) {\n    logger.warn('Connect ignored. Currently connecting.');\n    return;\n  }\n\n  if (this.closed) {\n    logger.warn('Connect ignored. Consumer closed.');\n    return;\n  }\n\n  logger.debug('Connecting %s', this.client.clientId);\n  var self = this;\n\n  this.connecting = true;\n  this.emit('rebalancing');\n\n  async.waterfall(\n    [\n      function (callback) {\n        if (typeof self.options.onRebalance === 'function') {\n          self.options.onRebalance(self.generationId != null && self.memberId != null, function (error) {\n            if (error) {\n              return callback(error);\n            }\n            callback(null);\n          });\n          return;\n        }\n        callback(null);\n      },\n      function (callback) {\n        if (self.options.autoCommit && self.generationId != null && self.memberId) {\n          self.commit(true, function (error) {\n            if (error) {\n              return callback(error);\n            }\n            callback(null);\n          });\n          return;\n        }\n        callback(null);\n      },\n      function (callback) {\n        if (self.client.coordinatorId) {\n          return callback(null, null);\n        }\n        self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);\n      },\n\n      function (coordinatorInfo, callback) {\n        logger.debug('GroupCoordinator Response:', coordinatorInfo);\n        if (coordinatorInfo) {\n          self.setCoordinatorId(coordinatorInfo.coordinatorId);\n        }\n        self.client.sendJoinGroupRequest(\n          self.options.groupId,\n          emptyStrIfNull(self.memberId),\n          self.options.sessionTimeout,\n          self.protocols,\n          callback\n        );\n      },\n\n      function (joinGroupResponse, callback) {\n        self.handleJoinGroup(joinGroupResponse, callback);\n      },\n\n      function (groupAssignment, callback) {\n        logger.debug('SyncGroup Request from %s', self.memberId);\n        self.client.sendSyncGroupRequest(\n          self.options.groupId,\n          self.generationId,\n          self.memberId,\n          groupAssignment,\n          callback\n        );\n      },\n\n      function (syncGroupResponse, callback) {\n        self.handleSyncGroup(syncGroupResponse, callback);\n      }\n    ],\n    function (error, startFetch) {\n      self.connecting = false;\n      self.rebalancing = false;\n      if (error) {\n        return self.recovery.tryToRecoverFrom(error, 'connect');\n      }\n\n      self.ready = true;\n      self.recovery.clearError();\n\n      logger.debug('generationId', self.generationId);\n\n      logger.debug('startFetch is', startFetch);\n      self._resetFetchState();\n      if (startFetch) {\n        self.clearPendingFetches();\n        self.fetch();\n      }\n      self.scheduleTopicPartitionCheck();\n      self.startHeartbeats();\n      self.emit('connect');\n      self.emit('rebalanced');\n    }\n  );\n};\n\nConsumerGroup.prototype.clearPendingFetches = function () {\n  _.forEach(this.client.getBrokers(true), broker => {\n    if (broker.socket.waiting) {\n      broker.socket.waiting = false;\n      this.client.clearCallbackQueue(broker.socket);\n    }\n  });\n};\n\nConsumerGroup.prototype.scheduleReconnect = function (timeout) {\n  assert(timeout);\n  this.rebalancing = true;\n\n  if (this.reconnectTimer) {\n    clearTimeout(this.reconnectTimer);\n  }\n\n  var self = this;\n  this.reconnectTimer = setTimeout(function () {\n    self.reconnectTimer = null;\n    self.connect();\n  }, timeout);\n};\n\nConsumerGroup.prototype.startHeartbeats = function () {\n  assert(this.options.sessionTimeout > 0);\n  assert(this.ready, 'consumerGroup is not ready');\n\n  const heartbeatIntervalMs = this.options.heartbeatInterval || Math.floor(this.options.sessionTimeout / 3);\n\n  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);\n  this.stopHeartbeats();\n\n  let heartbeat = this.sendHeartbeat();\n\n  this.heartbeatInterval = setInterval(() => {\n    // only send another heartbeat if we got a response from the last one\n    if (heartbeat.verifyResolved()) {\n      heartbeat = this.sendHeartbeat();\n    }\n  }, heartbeatIntervalMs);\n};\n\nConsumerGroup.prototype.stopHeartbeats = function () {\n  this.heartbeatInterval && clearInterval(this.heartbeatInterval);\n};\n\nConsumerGroup.prototype.leaveGroup = function (callback) {\n  logger.debug('%s leaving group', this.client.clientId);\n  var self = this;\n  this.stopHeartbeats();\n  if (self.generationId != null && self.memberId) {\n    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {\n      self.generationId = null;\n      callback(error);\n    });\n  } else {\n    callback(null);\n  }\n};\n\nConsumerGroup.prototype.sendHeartbeat = function () {\n  assert(this.memberId, 'invalid memberId');\n  assert(this.generationId >= 0, 'invalid generationId');\n  // logger.debug('%s â¤ï¸  ->', this.client.clientId);\n  var self = this;\n\n  function heartbeatCallback (error) {\n    if (error) {\n      logger.warn('%s Heartbeat error:', self.client.clientId, error);\n      self.recovery.tryToRecoverFrom(error, 'heartbeat');\n    }\n    // logger.debug('%s ðŸ’š <-', self.client.clientId, error);\n  }\n\n  const heartbeat = new Heartbeat(this.client, heartbeatCallback);\n  heartbeat.send(this.options.groupId, this.generationId, this.memberId);\n\n  return heartbeat;\n};\n\nConsumerGroup.prototype.fetchOffset = function (payloads, cb) {\n  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);\n};\n\nConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {\n  if (this.generationId && this.memberId) {\n    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n};\n\nConsumerGroup.prototype.addTopics = function (topics, cb) {\n  topics = Array.isArray(topics) ? topics : [topics];\n\n  if (!this.client.ready) {\n    this.client.once('ready', () => this.addTopics(topics, cb));\n    return;\n  }\n\n  async.series(\n    [\n      callback => this.client.topicExists(topics, callback),\n      callback =>\n        this.options.autoCommit && this.generationId != null && this.memberId\n          ? this.commit(true, callback)\n          : callback(null),\n      callback => this.leaveGroup(callback),\n      callback => {\n        this.topics = this.topics.concat(topics);\n        this.setupProtocols(this.options.protocol);\n        this.connect();\n        callback(null);\n      }\n    ],\n    error => (error ? cb(error) : cb(null, `Add Topics ${topics.join(',')} Successfully`))\n  );\n};\n\nConsumerGroup.prototype.removeTopics = function (topics, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n\n  async.series(\n    [\n      callback => this.client.topicExists(topics, callback),\n      callback =>\n        this.options.autoCommit && this.generationId != null && this.memberId\n          ? this.commit(true, callback)\n          : callback(null),\n      callback => this.leaveGroup(callback),\n      callback => {\n        this.topics = _.difference(this.topics, topics);\n        this.setupProtocols(this.options.protocol);\n        this.connect();\n        callback(null);\n      }\n    ],\n    error => (error ? cb(error) : cb(null, `Remove Topics ${topics.join(',')} Successfully`))\n  );\n};\n\nConsumerGroup.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = { topic: p };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n    return p;\n  });\n};\n\nConsumerGroup.prototype.buildPayloadMap = function (payloads) {\n  const payloadMap = {};\n  payloads.forEach(({ topic, partition, offset }) => {\n    payloadMap[topic] = payloadMap[topic] || {};\n    payloadMap[topic][partition] = offset;\n  });\n  return payloadMap;\n};\n\n/*\n * Update offset info in current payloads\n * @param {Object} Topic-partition-offset\n * @param {Boolean} Don't commit when initing consumer\n */\nConsumerGroup.prototype.updateOffsets = function (topics, initing) {\n  this.topicPayloads.forEach(p => {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;\n      else p.offset = offset;\n      // Update the map\n      this.needToCommit = true;\n    }\n    this.payloadMap[p.topic] = this.payloadMap[p.topic] || {};\n    this.payloadMap[p.topic][p.partition] = p.offset;\n  });\n\n  if (this.options.autoCommit && !initing) {\n    this.autoCommit(false, function (err) {\n      err && logger.debug('auto commit offset', err);\n    });\n  }\n};\n\nConsumerGroup.prototype._onFetchDone = function (topics) {\n  this.updateOffsets(topics);\n  if (--this._pendingFetches > 0) {\n    return;\n  }\n  this._isFetchPending = false;\n  if (!this.paused) {\n    setImmediate(() => this.fetch());\n  }\n};\n\nConsumerGroup.prototype._resetFetchState = function () {\n  this._pendingFetches = 0;\n  this._isFetchPending = false;\n};\n\nConsumerGroup.prototype._onFetchProcessing = function () {\n  this._pendingFetches++;\n};\n\nConsumerGroup.prototype.fetch = function () {\n  if (!this.ready || this.rebalancing || this.paused || this.closing) {\n    return;\n  }\n  if (this._isFetchPending) {\n    return;\n  }\n  this._isFetchPending = true;\n\n  this.client.sendFetchRequest(\n    this,\n    this.topicPayloads,\n    this.options.fetchMaxWaitMs,\n    this.options.fetchMinBytes,\n    this.options.maxTickMessages,\n    error => {\n      if (error) {\n        this._resetFetchState();\n      }\n    }\n  );\n};\n\nConsumerGroup.prototype.setOffset = function (topic, partition, offset) {\n  this.topicPayloads.every(function (p) {\n    // eslint-disable-next-line eqeqeq\n    if (p.topic === topic && p.partition == partition) {\n      p.offset = offset;\n      return false;\n    }\n    return true;\n  });\n};\n\nConsumerGroup.prototype.pause = function () {\n  this.paused = true;\n};\n\nConsumerGroup.prototype.resume = function () {\n  this.paused = false;\n  this.fetch();\n};\n\nfunction autoCommit (force, cb) {\n  if (arguments.length === 1) {\n    cb = force;\n    force = false;\n  }\n\n  if (!force) {\n    if (this.committing) return cb(null, 'Offset committing');\n    if (!this.needToCommit) return cb(null, 'Commit not needed');\n  }\n\n  this.needToCommit = false;\n  this.committing = true;\n  setTimeout(\n    function () {\n      this.committing = false;\n    }.bind(this),\n    this.options.autoCommitIntervalMs\n  ).unref();\n\n  var commits = this.topicPayloads.filter(function (p) {\n    return p.offset !== -1;\n  });\n\n  if (commits.length) {\n    this.sendOffsetCommitRequest(commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n}\n\nConsumerGroup.prototype.commit = ConsumerGroup.prototype.autoCommit = autoCommit;\n\nConsumerGroup.prototype.close = function (force, cb) {\n  var self = this;\n  this.ready = false;\n\n  this.stopHeartbeats();\n  clearTimeout(this.topicPartitionCheckTimer);\n\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n\n  async.series(\n    [\n      function (callback) {\n        if (force) {\n          self.commit(true, callback);\n          return;\n        }\n        callback(null);\n      },\n      function (callback) {\n        self.leaveGroup(function (error) {\n          if (error) {\n            logger.error('Leave group failed with', error);\n          }\n          callback(null);\n        });\n      },\n      function (callback) {\n        self.client.close(callback);\n      }\n    ],\n    function (error) {\n      if (error) {\n        return cb(error);\n      }\n      self.closed = true;\n      cb(null);\n    }\n  );\n};\n\nmodule.exports = ConsumerGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}